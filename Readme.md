ПОСЛЕДНИЕ ИЗМЕНЕНИЯ
-------------------------
Если проверка домашнего задания осуществляется в LINUX, пожалуйста раскомментируйте
в Makefile в строке 7 флаг -D LINUX, для поддержки очистки экрана при работе программы


Добавлена поддержка работы с файлами.
Поддержка работы с файлами реализована через создание класса FileSubsystem в server.h
класс FileSubsystem определен внутри класса Server. Создается по умолчанию экземпляр
класса с одноименным названием (fileSubsystem).

Вначале запуска Server "инициализирует" файловую подсистему через вызов метода init() y
fileSubsystem. Если метод возвращает false (Инициализация не успешна) происходит выброс
исключения, программа аварийно самостоятельно завершается.
Поводом для завершения может быть отсутствие прав на работу с нужными файлами или
директориями.

В свою очередь FileSubsystem либо создает (если нет), либо открывает необходимые файлы для
работы сервера, такие как users, global_messages. Далее в ходе работы, при необходимости
работы с приватными сообщениями пользователей, создает дополнительные соответствующие файлы
для каждого пользователя.

Необходимые файлы для работы определены через #define в заголовке server.h
GLOBAL_MESSAGES_FILE - файл глобальных сообщений сервера
USERS_FILE - файл хранения зарегистрированных пользователей
PERSONAL_MESSAGES_PATH - директория для хранения персональных файлов пользователей с личными
сообщениями.

FileSubsystem никак не влияет на файловые потоки, кроме как связывает их с файлами, создает
директории если необходимо, а так же каждый раз при создании или открытии файла, пытается
выставить права, и в конце концов предоставляет готовые файловые потоки серверу.

В заголове server.h есть определения по загрузке, хранению кол-ва сообщений.
Сервер хранит в памяти кол-во сообщений, загружаемое им из файла, с учетом коэффициента.
При превышении этого значения, освобождается память от старых сообщений.
В дальнейшем клиент может загрузить необходимое кол-во сообщений, и сервер загрузит их
из файла.


-----------------------------

Я пересмотрел архитектуру, разделил на серверную и клиентскую часть, чтобы в дальнейшем
было проще развивать проект.
    Плюс я долго думал над тем, как хранить пользователей на сервере.
    Основной упор был на то, чтобы обращаться к пользователям можно было быстро.
    У пользователей есть два поля. login и nickname.
    Причем серверная часть в основном работает через login, клиентская напротив через nickname.

Хранить в отсортированном виде в последовательном контейнере не получится. Т.к. юзеры хранятся
в отсортированном виде только по одному полю.

Мне изначально пришла в голову идея создать собственное префиксное дерево.
В нем я хранил одновременно и логины и ники, со своими маркерами и указателями на нужный адрес
пользователя.

Как оказалось на практике, такая структура потребляет очень много памяти.
Я генерировал случайные логины и ники, добавляя их в дерево. Примерно после 800 000 добавлений,
память заканчивалась, компьютер зависал. Надо было на калькуляторе посчитать примерно сразу :)

В итоге пришел к идее хранить в двух "std::map" и логины и никнеймы. Памяти нужно в несколько раз
меньше. Доступ быстрый. Юзеры хранятся в куче где попало, без контейнера. Плюс появилась возможность
предоставить пользователям выбирать большее кол-во символов для своих login и nickname. И главное, избавился
от мучений по грамотному написанию собственного ассоциативного контейнера.



-------
В заголовочном файле server.h определено пространство имен requestStructures.
В нем описаны структуры  для запросов от клиента серверу.
Клиент обращается к серверу через перегруженную у функцию request с аргументами в виде структур из
указанного выше пространства имен.


Для идентификации клиента сервером, при аутентификации клиента,
сервером генерируется дескриптор из 20ти символов.
В дальнейшем при отправке запросов на сервер, этот дескриптор передается внутри любого запроса клиентом.

В main создается для примера один сервер и один клиент. Через метод connect() подключаем клиента к серверу.

Далее в зависимости от выбора пользователя - вызываются функции для логина
или регистрации.
В моем решении функции вызываются одна из другой, что позволяет создать
иллюзию текстового меню.
Таким образом например возврат в предыдущее меню осуществляется путем
завершения текущей функции.

      Порядок вызова основных функций:
                   entry()
                 /          \
             /                \
          /                    \
    authentication ()      registration()
       |
     userSpace()

   Функция userSpace() вызывается при успешном логе на сервере.
   У пользователя есть возможность отправлять команды прямо во время ввода.
  Для этого необходимо добавить в начале сообщения символ ':'.
   Пользователь имеет возможность отправлять приватные сообщения другим пользователям,
зарегистрированным на сервере.

       На данный момент список возможных команд следующий:
       :list - отображает пользователей на сервере;
       :user - обращение к пользователю. Пример: ":user another_user";
         Если после имени пользователя нет аргументов, предлагается ввод сообщения
    для отправки ему, иначе все переданные аргументы интерпретируются как сообщение.
       :priv - отображает приватные сообщения;
       :out (эквивалент :q) - выход из учетной записи;
       :exit - выход из программы;
       :help - вывод текущей справки.



Пожалуйста, расскажите о том, как лучше всего делать взаимодействие между клиентом и сервером.
И каким образом сервер должен хранить информацию о пользователях и т.п.
Спасибо!.
